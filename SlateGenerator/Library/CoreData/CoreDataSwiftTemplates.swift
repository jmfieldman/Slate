//
//  CoreDataSwiftTemplates.swift
//  Copyright Â© 2018 Jason Fieldman.
//

import Foundation

/// Inputs:
///  * FILENAME - The filename string
///  * EXTRAIMPORT - Import an additional module if desired
let template_CD_Swift_fileheader: String = """
// {FILENAME}.swift
//
// ----- DO NOT MODIFY -----
// This file was automatically generated by slate
// ----- DO NOT MODIFY -----

import Foundation
import CoreData
{IMPORTS}
"""

/// Inputs:
///  * OBJTYPE - Either `class` or `struct`
///  * SLATECLASS - The Slate immutable class name
///  * COREDATACLASS - The backing Core Data class name
///  * ATTRASSIGNMENT - A series of attribute assignments for this class
///  * ATTRDECLARATIONS - A series of attribute declarations
let template_CD_Swift_SlateClassImpl: String = """
public {OBJTYPE} {SLATECLASS}: Sendable {

    // -- Attribute Declarations --
{ATTRDECLARATIONS}
    // -- Attribute Names --

    public struct Attributes {
{ATTRNAMES}
    }

    public struct Relationships {
{RELNAMES}
    }

    /**
     Each immutable data model object should have an associated SlateID (in the
     core data case, the NSManagedObjectID.  This is a cross-mutation identifier
     for the object.
    */
    public let slateID: NSManagedObjectID

    /**
     Instantiation is public so that Slate instances can create immutable objects
     from corresponding managed objects. You should never manually construct this in code.
     */
    public init(managedObject: ManagedPropertyProviding) {
        // Immutable objects should only be created inside Slate contexts
        // (by the Slate engine)
        guard Thread.current.threadDictionary["kThreadKeySlateQueryContext"] != nil else {
            fatalError("It is a programming error to instantiate an immutable Slate object from outside of a Slate query context.")
        }

        // All objects inherit the objectID
        self.slateID = managedObject.objectID

        // Attribute assignment
{ATTRASSIGNMENT}
    }

    /**
     Allow the creation of a Slate-exposed class/struct with all of its parameters.
     Note that this is internal -- this is for use only in unit tests (using the
     @testable import directive).  You should never create values with this
     constructor in normal code.
     */
    internal init(
        {INITPARAMS}
    ) {
        // Internally created objects have no real managed object ID
        self.slateID = NSManagedObjectID()

        {INITPARAMASSIGNMENTS}
    }

    // -- Substruct Definitions

{SUBSTRUCTS}
}


"""

/// Inputs:
///  * SLATESUBSTRUCT - The Slate substruct struct name
///  * COREDATACLASS - The backing Core Data class name
///  * ATTRASSIGNMENT - A series of attribute assignments for this class
///  * ATTRDECLARATIONS - A series of attribute declarations
let template_CD_Swift_SlateSubstructImpl: String = """
    public struct {SLATESUBSTRUCT}: Equatable, Sendable {

        // -- Attribute Declarations --
{ATTRDECLARATIONS}

        /**
         Instantiation is private to this file; Substructs should only be instantiated
         by their parent Slate object.
         */
        fileprivate init(managedObject: ManagedPropertyProviding) {

            // Attribute assignment
{ATTRASSIGNMENT}
        }

        /**
         Allow the creation of a Slate-exposed class/struct with all of its parameters.
         Note that this is internal -- this is for use only in unit tests (using the
         @testable import directive).  You should never create values with this
         constructor in normal code.
        */
        internal init(
            {INITPARAMS}
        ) {
            {INITPARAMASSIGNMENTS}
        }
    }


"""

/// Inputs:
///  * REL - The name of the relationship
let template_CD_Swift_RelName: String = "        public static let {REL} = \"{REL}\"\n"

///  * ATTR - The name of the attribute
let template_CD_Swift_AttrName: String = "        public static let {ATTR} = \"{ATTR}\"\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * CONV - The conversion to the proper swift type
let template_CD_Swift_AttrAssignment: String = "        self.{ATTR} = managedObject.{ATTR}{CONV}\n"

/// Inputs:
///  * ATTR - The name of the attribute
let template_CD_Swift_AttrIntAssignment: String = "        self.{ATTR} = Int(managedObject.{ATTR})\n"

/// Inputs:
///  * ATTR - The name of the attribute
let template_CD_Swift_AttrIntOptAssignment: String = "        self.{ATTR} = managedObject.{ATTR}.flatMap { Int($0) }\n"

/// Inputs:
///  * ATTR - The name of the attribute
let template_CD_Swift_AttrEnumAssignment: String = "        self.{ATTR} = Int(managedObject.{ATTR})\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * TYPE - The type of the managed object
let template_CD_Swift_AttrForceAssignment: String = "        self.{ATTR} = { let t: {TYPE}? = managedObject.{ATTR}{CONV}; return t! }()\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * TYPE - The type of substruct
let template_CD_Swift_AttrAssignmentForSubstruct: String = "        self.{ATTR} = {TYPE}(managedObject: managedObject)\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * TYPE - The type of substruct
let template_CD_Swift_AttrAssignmentForOptSubstruct: String = "        self.{ATTR} = managedObject.{ATTR}_has ? {TYPE}(managedObject: managedObject) : nil\n"

/// Inputs:
///  * STRNAME - The managed property's struct prefix
///  * ATTR - The name of the attribute
///  * CONV - The conversion to the proper swift type
let template_CD_Swift_SubstructAttrAssignment: String = "            self.{ATTR} = managedObject.{STRNAME}_{ATTR}{CONV}\n"

/// Inputs:
///  * STRNAME - The managed property's struct prefix
///  * ATTR - The name of the attribute
let template_CD_Swift_SubstructAttrIntAssignment: String = "            self.{ATTR} = Int(managedObject.{STRNAME}_{ATTR})\n"

/// Inputs:
///  * STRNAME - The managed property's struct prefix
///  * ATTR - The name of the attribute
let template_CD_Swift_SubstructAttrIntOptAssignment: String = "            self.{ATTR} = managedObject.{STRNAME}_{ATTR}.flatMap { Int($0) }\n"

/// Inputs:
///  * STRNAME - The managed property's struct prefix
///  * ATTR - The name of the attribute
///  * TYPE - The type of the managed object
///  * DEF - The default value
let template_CD_Swift_SubstructAttrForceAssignment: String = "            self.{ATTR} = { let t: {TYPE}? = managedObject.{STRNAME}_{ATTR}{CONV}; return t ?? {DEF} }()\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * TYPE - The immutable type of the attribute
///  * OPTIONAL - Use `?` to indicate that this attribute is optional
let template_CD_Swift_AttrDeclaration: String = "    {ACCESS} let {ATTR}: {TYPE}{OPTIONAL}\n"

/// Inputs:
///  * ATTR - The name of the attribute
///  * TYPE - The immutable type of the attribute
///  * OPTIONAL - Use `?` to indicate that this attribute is optional
let template_CD_Swift_SubstructAttrDeclaration: String = "        {ACCESS} let {ATTR}: {TYPE}{OPTIONAL}\n"

/// Inputs:
///  * SLATECLASS - The name of the immutable slate class
///  * ATTRS - Equatable attributes
let template_CD_Swift_SlateEquatable: String = """
extension {SLATECLASS}: Equatable {
    public static func ==(lhs: {SLATECLASS}, rhs: {SLATECLASS}) -> Bool {
        return (lhs.slateID == rhs.slateID){ATTRS}
    }
}


"""

// MARK: - Core Data Entity Generators

/// Inputs:
///  * PROPERTIES - Core Data properties of the class
///  * CDENTITYCLASS - Core Data entity class name
///  * CDENTITYNAME - Core Data entity name
///  * SLATECLASS - Slate Immutable class name
let template_CD_Entity: String = """
// {FILENAME}
//
// ----- DO NOT MODIFY -----
// This file was automatically generated by slate
// ----- DO NOT MODIFY -----

import Foundation
import CoreData{CDIMPORTS}

@objc({CDENTITYCLASS})
public final class {CDENTITYCLASS}: NSManagedObject, {SLATECLASS}.ManagedPropertyProviding {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<{CDENTITYCLASS}> {
        return NSFetchRequest<{CDENTITYCLASS}>(entityName: "{CDENTITYNAME}")
    }

    @nonobjc static func create(in moc: NSManagedObjectContext) -> {CDENTITYCLASS}? {
        NSEntityDescription.entity(forEntityName: "{CDENTITYNAME}", in: moc).flatMap {
            {CDENTITYCLASS}(entity: $0, insertInto: moc)
        }
    }

{PROPERTIES}
}

extension {CDENTITYCLASS}: SlateObjectConvertible {
    /**
     Instantiates an immutable Slate class from the receiving Core Data class.
     */
    public var slateObject: SlateObject {
        {SLATECLASS}(managedObject: self)
    }
}

extension {SLATECLASS}: SlateObject {
    public static var __slate_managedObjectType: NSManagedObject.Type = {CDENTITYCLASS}.self
}

extension {SLATECLASS}: SlateManagedObjectRelating {
    public typealias ManagedObjectType = {CDENTITYCLASS}
}

{RELATIONS}

"""

/// Inputs:
///  * OBJQUAL - The SO qualifier string; `: ` for class or ` == ` for struct
///  * SLATECLASS - The name of the immutable slate class
///  * RELATIONSHIPS - The listing of relationship lookups
let template_CD_Swift_SlateRelationshipResolver: String = """
public extension SlateRelationshipResolver where SO{OBJQUAL}{SLATECLASS} {
{RELATIONSHIPS}
}


"""

/// Inputs:
///  * RELATIONSHIPNAME - The attribute/name of the relationship
///  * TARGETSLATECLASS - The name of the immutable slate class of the relationship target
///  * COREDATACLASS - The name of the Core Data class of the relationship target
let template_CD_Swift_SlateRelationshipToMany: String = """
    var {RELATIONSHIPNAME}: [{TARGETSLATECLASS}] {
        guard let mo = self.managedObject as? {COREDATACLASS} else {
            fatalError("Fatal casting error")
        }

        guard let set = mo.{RELATIONSHIPNAME}{SET} else {
            return []
        }

        return self.convert(set) as! [{TARGETSLATECLASS}]
    }


"""

/// Inputs:
///  * RELATIONSHIPNAME - The attribute/name of the relationship
///  * TARGETSLATECLASS - The name of the immutable slate class of the relationship target
///  * COREDATACLASS - The name of the Core Data class of the relationship target
///  * OPTIONAL - Should be `?` if the toOne is optional
///  * NONOPTIONAL - Should be `!` if the toOne is required
let template_CD_Swift_SlateRelationshipToOne: String = """
    var {RELATIONSHIPNAME}: {TARGETSLATECLASS}{OPTIONAL} {
        guard let mo = self.managedObject as? {COREDATACLASS} else {
            fatalError("Fatal casting error")
        }

        return self.convert(mo.{RELATIONSHIPNAME}) as{NONOPTIONAL}{OPTIONAL} {TARGETSLATECLASS}
    }


"""

/// Inputs:
///  * VARNAME - Variable name
///  * TYPE - The property type
///  * OPTIONAL - The string "?" if the type is optional
let template_CD_Entity_Property: String = "    @NSManaged public var {VARNAME}: {TYPE}{OPTIONAL}\n"

/// Inputs:
///  * SLATECLASS - Name of the slate class
///  * PROPERTIES - List of protocol properties
let template_CD_Property_Provider_Protocol: String = """
public extension {SLATECLASS} {
    protocol ManagedPropertyProviding: NSManagedObject {
        {PROPERTIES}
    }
}

"""

/// Inputs:
///  * VARNAME - Variable name
///  * TYPE - The property type
///  * OPTIONAL - The string "?" if the type is optional
let template_CD_Property_Provider_Attr: String = "    var {VARNAME}: {TYPE}{OPTIONAL} { get }\n"
